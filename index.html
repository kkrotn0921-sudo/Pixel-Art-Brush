<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Art Brush - ドット絵加工ツール</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #f0f2f5;
            font-family: 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', Meiryo, sans-serif;
        }
        .canvas-container {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            background: white;
            border-radius: 1rem;
            padding: 2rem;
        }
        .image-editor-area {
            position: relative;
            display: inline-block;
            user-select: none;
            overflow: hidden;
            border-radius: 0.75rem;
            background-color: #f9fafb;
            border: 2px dashed #e5e7eb;
            transition: border-color 0.3s;
            cursor: crosshair;
        }
        .image-editor-area.drag-over {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        #originalImg {
            display: block;
            max-width: 100%;
            height: auto;
            -webkit-user-drag: none;
        }
        #pixelCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            image-rendering: pixelated;
        }
        .range-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 999px;
            outline: none;
        }
        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .mode-button {
            transition: all 0.2s;
            border: 1px solid #e5e7eb;
        }
        .mode-button.active {
            background-color: #3b82f6;
            color: white;
            border-color: #2563eb;
            box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.3);
        }
        footer {
            margin-top: 3rem;
            color: #9ca3af;
            font-size: 0.875rem;
        }
    </style>
</head>
<body class="min-h-screen py-8 px-4">
    <div class="max-w-6xl mx-auto">
        <!-- Header -->
        <header class="text-center mb-10">
            <h1 class="text-4xl font-black text-gray-900 mb-3 tracking-tight">Pixel Art Brush</h1>
            <p class="text-gray-500 text-lg font-medium">画像の一部をなぞるだけで、スタイリッシュなドット絵に加工</p>
        </header>

        <main class="canvas-container">
            <!-- Toolbar -->
            <div class="grid grid-cols-1 lg:grid-cols-6 gap-6 mb-8 border-b border-gray-100 pb-8">
                <!-- 1. Upload -->
                <div class="space-y-2">
                    <label class="block text-xs font-bold text-gray-400 uppercase tracking-wider">1. 画像を読み込む</label>
                    <label for="imageLoader" class="flex items-center justify-center w-full px-4 py-2 bg-white border border-gray-300 rounded-lg shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50 cursor-pointer transition-colors">
                        ファイルを選択
                    </label>
                    <input type="file" id="imageLoader" accept="image/*" class="hidden">
                </div>

                <!-- 2. Mode -->
                <div class="space-y-2">
                    <label class="block text-xs font-bold text-gray-400 uppercase tracking-wider">2. モード</label>
                    <div class="flex p-1 bg-gray-100 rounded-xl">
                        <button id="drawModeBtn" class="mode-button active flex-1 py-1.5 rounded-lg text-xs font-bold">鉛筆</button>
                        <button id="eraseModeBtn" class="mode-button flex-1 py-1.5 rounded-lg text-xs font-bold">消しゴム</button>
                    </div>
                </div>

                <!-- 3. Pixel Size -->
                <div class="space-y-2">
                    <label class="block text-xs font-bold text-gray-400 uppercase tracking-wider">3. ドットの大きさ</label>
                    <div class="flex justify-between items-center">
                        <span id="pixelValue" class="text-sm font-bold text-blue-600 bg-blue-50 px-2 py-0.5 rounded">32 px</span>
                    </div>
                    <input type="range" id="pixelRange" min="4" max="150" step="1" value="32" class="range-slider">
                </div>

                <!-- 4. Brush Size -->
                <div class="space-y-2">
                    <label class="block text-xs font-bold text-gray-400 uppercase tracking-wider">4. ブラシの太さ</label>
                    <div class="flex justify-between items-center">
                        <span id="brushValue" class="text-sm font-bold text-blue-600 bg-blue-50 px-2 py-0.5 rounded">40 px</span>
                    </div>
                    <input type="range" id="brushRange" min="5" max="250" step="1" value="40" class="range-slider">
                </div>

                <!-- 5. Utility -->
                <div class="flex flex-col justify-end">
                    <button id="fillAllBtn" class="w-full bg-indigo-50 hover:bg-indigo-100 text-indigo-700 font-bold py-2 rounded-lg transition-colors text-xs border border-indigo-100 shadow-sm">
                        全体をドット化
                    </button>
                </div>

                <!-- 6. Actions -->
                <div class="flex items-end gap-2">
                    <button id="clearBtn" class="flex-1 bg-gray-100 hover:bg-gray-200 text-gray-600 font-bold py-2 px-2 rounded-lg transition-colors text-xs">
                        リセット
                    </button>
                    <button id="downloadBtn" class="flex-[1.5] bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-2 rounded-lg shadow-md hover:shadow-lg transition-all text-xs">
                        保存する
                    </button>
                </div>
            </div>

            <!-- Editor Wrapper -->
            <div class="flex justify-center">
                <div id="editorWrapper" class="image-editor-area group">
                    <div id="placeholderText" class="py-32 px-12 text-center">
                        <div class="mb-4 flex justify-center text-gray-300">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                            </svg>
                        </div>
                        <p class="text-gray-400 font-medium">画像をここにドラッグ＆ドロップ、またはファイルを選択</p>
                    </div>
                    <img id="originalImg" alt="Target Image" draggable="false">
                    <canvas id="pixelCanvas"></canvas>
                </div>
            </div>
            
            <div class="mt-8 grid grid-cols-1 md:grid-cols-3 gap-6 text-center text-xs text-gray-400 border-t pt-8 border-gray-50">
                <div>
                    <h3 class="font-bold text-gray-500 mb-1">なぞって加工</h3>
                    <p>鉛筆モードでなぞった場所だけがドット化されます。</p>
                </div>
                <div>
                    <h3 class="font-bold text-gray-500 mb-1">消しゴムで修正</h3>
                    <p>消しゴムを使うと、ドット化を解除して元の画像に戻せます。</p>
                </div>
                <div>
                    <h3 class="font-bold text-gray-500 mb-1">高画質ダウンロード</h3>
                    <p>保存ボタンを押すと、元の解像度で画像を保存できます。</p>
                </div>
            </div>
        </main>

        <footer class="text-center">
            <p>&copy; 2024 Pixel Art Brush Tool. 全ての処理はブラウザ内で安全に行われます。</p>
        </footer>
    </div>

    <!-- Hidden Process Canvases -->
    <canvas id="outputCanvas" style="display:none;"></canvas>
    <canvas id="maskCanvas" style="display:none;"></canvas>

    <script>
        const imageLoader = document.getElementById('imageLoader');
        const originalImg = document.getElementById('originalImg');
        const pixelCanvas = document.getElementById('pixelCanvas');
        const outputCanvas = document.getElementById('outputCanvas');
        const maskCanvas = document.getElementById('maskCanvas');
        const pixelRange = document.getElementById('pixelRange');
        const pixelValue = document.getElementById('pixelValue');
        const brushRange = document.getElementById('brushRange');
        const brushValue = document.getElementById('brushValue');
        const clearBtn = document.getElementById('clearBtn');
        const fillAllBtn = document.getElementById('fillAllBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const editorWrapper = document.getElementById('editorWrapper');
        const placeholderText = document.getElementById('placeholderText');
        const drawModeBtn = document.getElementById('drawModeBtn');
        const eraseModeBtn = document.getElementById('eraseModeBtn');

        let isDrawing = false;
        let imgLoaded = false;
        let currentMode = 'draw'; 
        let paths = []; 
        let currentPath = [];

        originalImg.ondragstart = (e) => e.preventDefault();

        // Mode Switching
        drawModeBtn.onclick = () => {
            currentMode = 'draw';
            drawModeBtn.classList.add('active');
            eraseModeBtn.classList.remove('active');
        };
        eraseModeBtn.onclick = () => {
            currentMode = 'erase';
            eraseModeBtn.classList.add('active');
            drawModeBtn.classList.remove('active');
        };

        function loadFile(file) {
            if (!file || !file.type.startsWith('image/')) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                originalImg.onload = () => {
                    imgLoaded = true;
                    placeholderText.style.display = 'none';
                    resizeCanvases();
                    clearCanvas();
                };
                originalImg.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function resizeCanvases() {
            const w = originalImg.clientWidth;
            const h = originalImg.clientHeight;
            pixelCanvas.width = w;
            pixelCanvas.height = h;
            maskCanvas.width = w;
            maskCanvas.height = h;
        }

        imageLoader.onchange = (e) => loadFile(e.target.files[0]);

        editorWrapper.onmousedown = (e) => {
            if (!imgLoaded || e.button !== 0) return;
            isDrawing = true;
            currentPath = [];
            addPoint(e);
            e.preventDefault();
        };

        window.onmousemove = (e) => {
            if (!isDrawing) return;
            addPoint(e);
            drawAll();
        };

        window.onmouseup = () => {
            if (isDrawing && currentPath.length > 0) {
                paths.push({
                    points: currentPath,
                    brushSize: parseInt(brushRange.value),
                    mode: currentMode,
                    type: 'stroke'
                });
            }
            isDrawing = false;
            currentPath = [];
            drawAll();
        };

        function addPoint(e) {
            const rect = editorWrapper.getBoundingClientRect();
            currentPath.push({
                x: e.clientX - rect.left,
                y: e.clientY - rect.top
            });
        }

        fillAllBtn.onclick = () => {
            if (!imgLoaded) return;
            paths.push({ mode: 'draw', type: 'fill' });
            drawAll();
        };

        pixelRange.oninput = (e) => {
            pixelValue.textContent = e.target.value + ' px';
            drawAll();
        };

        brushRange.oninput = (e) => {
            brushValue.textContent = e.target.value + ' px';
        };

        clearBtn.onclick = clearCanvas;

        function clearCanvas() {
            paths = [];
            currentPath = [];
            const ctx = pixelCanvas.getContext('2d');
            ctx.clearRect(0, 0, pixelCanvas.width, pixelCanvas.height);
            drawAll();
        }

        function drawMask(ctx, scale = 1) {
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const allActions = [...paths];
            if (currentPath.length > 0) {
                allActions.push({
                    points: currentPath,
                    brushSize: parseInt(brushRange.value),
                    mode: currentMode,
                    type: 'stroke'
                });
            }

            allActions.forEach(action => {
                if (action.mode === 'erase') {
                    ctx.globalCompositeOperation = 'destination-out';
                } else {
                    ctx.globalCompositeOperation = 'source-over';
                }

                if (action.type === 'fill') {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                } else if (action.points && action.points.length >= 2) {
                    ctx.lineWidth = action.brushSize * scale;
                    ctx.strokeStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(action.points[0].x * scale, action.points[0].y * scale);
                    for (let i = 1; i < action.points.length; i++) {
                        ctx.lineTo(action.points[i].x * scale, action.points[i].y * scale);
                    }
                    ctx.stroke();
                }
            });
            ctx.globalCompositeOperation = 'source-over';
        }

        function drawAll() {
            if (!imgLoaded) return;
            const pCtx = pixelCanvas.getContext('2d');
            const mCtx = maskCanvas.getContext('2d');
            pCtx.clearRect(0, 0, pixelCanvas.width, pixelCanvas.height);
            mCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);

            drawMask(mCtx);
            pCtx.save();
            const resolution = parseInt(pixelRange.value);
            const tempCanvas = document.createElement('canvas');
            const tCtx = tempCanvas.getContext('2d');
            tempCanvas.width = resolution;
            tempCanvas.height = Math.round(resolution * (originalImg.naturalHeight / originalImg.naturalWidth));
            tCtx.imageSmoothingEnabled = false;
            tCtx.drawImage(originalImg, 0, 0, tempCanvas.width, tempCanvas.height);
            pCtx.imageSmoothingEnabled = false;
            pCtx.drawImage(tempCanvas, 0, 0, pixelCanvas.width, pixelCanvas.height);
            pCtx.globalCompositeOperation = 'destination-in';
            pCtx.drawImage(maskCanvas, 0, 0);
            pCtx.restore();
        }

        downloadBtn.onclick = () => {
            if (!imgLoaded) return;
            const outCtx = outputCanvas.getContext('2d');
            const naturalW = originalImg.naturalWidth;
            const naturalH = originalImg.naturalHeight;
            outputCanvas.width = naturalW;
            outputCanvas.height = naturalH;
            const scaleX = naturalW / originalImg.clientWidth;

            outCtx.drawImage(originalImg, 0, 0);
            const pixelPartCanvas = document.createElement('canvas');
            pixelPartCanvas.width = naturalW;
            pixelPartCanvas.height = naturalH;
            const ppCtx = pixelPartCanvas.getContext('2d');

            const resolution = parseInt(pixelRange.value);
            const tempCanvas = document.createElement('canvas');
            const tCtx = tempCanvas.getContext('2d');
            tempCanvas.width = resolution;
            tempCanvas.height = Math.round(resolution * (naturalH / naturalW));
            tCtx.imageSmoothingEnabled = false;
            tCtx.drawImage(originalImg, 0, 0, tempCanvas.width, tempCanvas.height);
            ppCtx.imageSmoothingEnabled = false;
            ppCtx.drawImage(tempCanvas, 0, 0, naturalW, naturalH);

            const finalMaskCanvas = document.createElement('canvas');
            finalMaskCanvas.width = naturalW;
            finalMaskCanvas.height = naturalH;
            const fmCtx = finalMaskCanvas.getContext('2d');
            drawMask(fmCtx, scaleX);
            ppCtx.globalCompositeOperation = 'destination-in';
            ppCtx.drawImage(finalMaskCanvas, 0, 0);
            outCtx.drawImage(pixelPartCanvas, 0, 0);

            const link = document.createElement('a');
            link.download = 'pixel-art-export.png';
            link.href = outputCanvas.toDataURL();
            link.click();
        };

        editorWrapper.ondragover = (e) => { e.preventDefault(); editorWrapper.classList.add('drag-over'); };
        editorWrapper.ondragleave = () => { editorWrapper.classList.remove('drag-over'); };
        editorWrapper.ondrop = (e) => {
            e.preventDefault();
            editorWrapper.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) loadFile(e.dataTransfer.files[0]);
        };

        window.onresize = () => { if (imgLoaded) { resizeCanvases(); drawAll(); } };
    </script>
</body>
</html>
