<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pixel Art Brush - タップ対応版</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            background-color: #f0f2f5;
            font-family: 'Helvetica Neue', Arial, 'Hiragino Kaku Gothic ProN', 'Hiragino Sans', Meiryo, sans-serif;
            touch-action: manipulation;
        }
        .canvas-container {
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
            background: white;
            border-radius: 1rem;
            padding: 2rem;
        }
        .image-editor-area {
            position: relative;
            display: inline-block;
            user-select: none;
            overflow: hidden;
            border-radius: 0.75rem;
            background-color: #f9fafb;
            border: 2px dashed #e5e7eb;
            transition: border-color 0.3s;
            cursor: crosshair;
            max-width: 100%;
            max-height: 85vh; 
            touch-action: none;
        }
        .image-editor-area.drag-over {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
        #originalImg {
            display: block;
            max-width: 100%;
            max-height: 85vh;
            width: auto;
            height: auto;
            object-fit: contain;
            -webkit-user-drag: none;
        }
        #pixelCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            image-rendering: pixelated;
        }
        .range-slider {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: #e5e7eb;
            border-radius: 999px;
            outline: none;
        }
        .range-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: #3b82f6;
            cursor: pointer;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
        .mode-button {
            transition: all 0.2s;
            border: 1px solid #e5e7eb;
        }
        .mode-button.active {
            background-color: #3b82f6;
            color: white;
            border-color: #2563eb;
            box-shadow: 0 4px 6px -1px rgba(59, 130, 246, 0.3);
        }
        .number-input {
            width: 60px;
            text-align: center;
            border: 1px solid #e5e7eb;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            font-weight: bold;
            color: #3b82f6;
            background-color: #eff6ff;
            padding: 2px 0;
        }
        .number-input:focus {
            outline: 2px solid #3b82f6;
            outline-offset: -1px;
        }
    </style>
</head>
<body class="min-h-screen py-8 px-4">
    <div class="max-w-7xl mx-auto">
        <!-- Header -->
        <header class="text-center mb-10">
            <h1 class="text-4xl font-black text-gray-900 mb-3 tracking-tight">Pixel Art Brush</h1>
            <p class="text-gray-500 text-lg font-medium px-4">画像の一部をなぞるだけで、スタイリッシュなドット絵に加工</p>
        </header>

        <main class="canvas-container">
            <!-- Toolbar -->
            <div class="grid grid-cols-2 lg:grid-cols-6 gap-6 mb-8 border-b border-gray-100 pb-8">
                <!-- 1. Upload -->
                <div class="col-span-2 lg:col-span-1 space-y-2">
                    <label class="block text-xs font-bold text-gray-400 uppercase tracking-wider">1. 画像を読み込む</label>
                    <label for="imageLoader" class="flex items-center justify-center w-full px-4 py-2 bg-white border border-gray-300 rounded-lg shadow-sm text-sm font-medium text-gray-700 hover:bg-gray-50 cursor-pointer transition-colors">
                        ファイルを選択
                    </label>
                    <input type="file" id="imageLoader" accept="image/*" class="hidden">
                </div>

                <!-- 2. Mode -->
                <div class="col-span-2 lg:col-span-1 space-y-2">
                    <label class="block text-xs font-bold text-gray-400 uppercase tracking-wider">2. モード</label>
                    <div class="flex p-1 bg-gray-100 rounded-xl">
                        <button id="drawModeBtn" class="mode-button active flex-1 py-1.5 rounded-lg text-xs font-bold">鉛筆</button>
                        <button id="eraseModeBtn" class="mode-button flex-1 py-1.5 rounded-lg text-xs font-bold">消しゴム</button>
                    </div>
                </div>

                <!-- 3. Pixel Size -->
                <div class="col-span-1 lg:col-span-1 space-y-2">
                    <div class="flex justify-between items-center">
                        <label class="block text-xs font-bold text-gray-400 uppercase tracking-wider">3. ドットの大きさ</label>
                        <div class="flex items-center gap-1">
                            <input type="number" id="pixelInput" value="32" min="4" max="300" class="number-input">
                            <span class="text-[10px] font-bold text-gray-400">PX</span>
                        </div>
                    </div>
                    <input type="range" id="pixelRange" min="4" max="150" step="1" value="32" class="range-slider">
                </div>

                <!-- 4. Brush Size -->
                <div class="col-span-1 lg:col-span-1 space-y-2">
                    <div class="flex justify-between items-center">
                        <label class="block text-xs font-bold text-gray-400 uppercase tracking-wider">4. ブラシの太さ</label>
                        <div class="flex items-center gap-1">
                            <input type="number" id="brushInput" value="40" min="1" max="500" class="number-input">
                            <span class="text-[10px] font-bold text-gray-400">PX</span>
                        </div>
                    </div>
                    <input type="range" id="brushRange" min="5" max="250" step="1" value="40" class="range-slider">
                </div>

                <!-- 5. Utility -->
                <div class="col-span-1 lg:col-span-1 flex flex-col justify-end">
                    <button id="fillAllBtn" class="w-full bg-indigo-50 hover:bg-indigo-100 text-indigo-700 font-bold py-2 rounded-lg transition-colors text-xs border border-indigo-100 shadow-sm">
                        全体をドット化
                    </button>
                </div>

                <!-- 6. Actions -->
                <div class="col-span-1 lg:col-span-1 flex items-end gap-2">
                    <button id="clearBtn" class="flex-1 bg-gray-100 hover:bg-gray-200 text-gray-600 font-bold py-2 rounded-lg transition-colors text-xs">
                        リセット
                    </button>
                    <button id="downloadBtn" class="flex-[1.5] bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 rounded-lg shadow-md hover:shadow-lg transition-all text-xs">
                        保存する
                    </button>
                </div>
            </div>

            <!-- Editor Wrapper -->
            <div class="flex justify-center overflow-auto pb-4">
                <div id="editorWrapper" class="image-editor-area group">
                    <div id="placeholderText" class="py-48 px-12 text-center min-w-[300px] md:min-w-[400px]">
                        <div class="mb-4 flex justify-center text-gray-300">
                            <svg xmlns="http://www.w3.org/2000/svg" class="h-16 w-16" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z" />
                            </svg>
                        </div>
                        <p class="text-gray-400 font-medium">画像をここにドラッグ＆ドロップ、またはファイルを選択</p>
                    </div>
                    <img id="originalImg" alt="Target Image" draggable="false">
                    <canvas id="pixelCanvas"></canvas>
                </div>
            </div>
            
            <div class="mt-8 grid grid-cols-1 md:grid-cols-3 gap-6 text-center text-xs text-gray-400 border-t pt-8 border-gray-50">
                <div>
                    <h3 class="font-bold text-gray-500 mb-1">なぞって加工</h3>
                    <p>鉛筆モードでなぞった場所だけがドット化されます。</p>
                </div>
                <div>
                    <h3 class="font-bold text-gray-500 mb-1">消しゴムで修正</h3>
                    <p>消しゴムを使うと、ドット化を解除して元の画像に戻せます。</p>
                </div>
                <div>
                    <h3 class="font-bold text-gray-500 mb-1">高精度・高画質</h3>
                    <p>元の写真の解像度を維持したまま、美しいドット絵を出力します。</p>
                </div>
            </div>
        </main>

        <footer class="text-center py-10">
            <p class="text-xs text-gray-400">&copy; 2024 Pixel Art Brush Tool. すべての画像処理はあなたのブラウザ内で行われます。</p>
        </footer>
    </div>

    <!-- Hidden Process Canvases -->
    <canvas id="outputCanvas" style="display:none;"></canvas>
    <canvas id="maskCanvas" style="display:none;"></canvas>

    <script>
        const imageLoader = document.getElementById('imageLoader');
        const originalImg = document.getElementById('originalImg');
        const pixelCanvas = document.getElementById('pixelCanvas');
        const outputCanvas = document.getElementById('outputCanvas');
        const maskCanvas = document.getElementById('maskCanvas');
        
        const pixelRange = document.getElementById('pixelRange');
        const pixelInput = document.getElementById('pixelInput');
        const brushRange = document.getElementById('brushRange');
        const brushInput = document.getElementById('brushInput');
        
        const clearBtn = document.getElementById('clearBtn');
        const fillAllBtn = document.getElementById('fillAllBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const editorWrapper = document.getElementById('editorWrapper');
        const placeholderText = document.getElementById('placeholderText');
        const drawModeBtn = document.getElementById('drawModeBtn');
        const eraseModeBtn = document.getElementById('eraseModeBtn');

        let isDrawing = false;
        let imgLoaded = false;
        let currentMode = 'draw'; 
        let paths = []; 
        let currentPath = [];

        // --- Helper: Get Coordinates ---
        function getPos(e) {
            const rect = editorWrapper.getBoundingClientRect();
            let clientX, clientY;
            
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        // --- Event Handlers (Mouse & Touch) ---
        function startDrawing(e) {
            if (!imgLoaded) return;
            if (e.type === 'mousedown' && e.button !== 0) return;
            isDrawing = true;
            currentPath = [];
            currentPath.push(getPos(e));
            if (e.type === 'touchstart') e.preventDefault();
        }

        function moveDrawing(e) {
            if (!isDrawing) return;
            currentPath.push(getPos(e));
            drawAll();
            if (e.cancelable) e.preventDefault();
        }

        function stopDrawing() {
            if (isDrawing && currentPath.length > 0) {
                paths.push({
                    points: currentPath,
                    brushSize: parseInt(brushInput.value),
                    mode: currentMode,
                    type: 'stroke'
                });
            }
            isDrawing = false;
            currentPath = [];
            drawAll();
        }

        // Mouse Events
        editorWrapper.addEventListener('mousedown', startDrawing);
        window.addEventListener('mousemove', moveDrawing);
        window.addEventListener('mouseup', stopDrawing);

        // Touch Events
        editorWrapper.addEventListener('touchstart', startDrawing, { passive: false });
        editorWrapper.addEventListener('touchmove', moveDrawing, { passive: false });
        editorWrapper.addEventListener('touchend', stopDrawing);

        // --- Logic Functions ---
        function loadFile(file) {
            if (!file || !file.type.startsWith('image/')) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                originalImg.onload = () => {
                    imgLoaded = true;
                    placeholderText.style.display = 'none';
                    resizeCanvases();
                    clearCanvas();
                };
                originalImg.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function resizeCanvases() {
            const w = originalImg.offsetWidth;
            const h = originalImg.offsetHeight;
            pixelCanvas.width = w;
            pixelCanvas.height = h;
            maskCanvas.width = w;
            maskCanvas.height = h;
        }

        imageLoader.onchange = (e) => loadFile(e.target.files[0]);

        drawModeBtn.onclick = () => { currentMode = 'draw'; drawModeBtn.classList.add('active'); eraseModeBtn.classList.remove('active'); };
        eraseModeBtn.onclick = () => { currentMode = 'erase'; eraseModeBtn.classList.add('active'); drawModeBtn.classList.remove('active'); };

        fillAllBtn.onclick = () => { if (!imgLoaded) return; paths.push({ mode: 'draw', type: 'fill' }); drawAll(); };
        clearBtn.onclick = clearCanvas;

        function clearCanvas() {
            paths = [];
            currentPath = [];
            if (imgLoaded) {
                const ctx = pixelCanvas.getContext('2d');
                ctx.clearRect(0, 0, pixelCanvas.width, pixelCanvas.height);
                drawAll();
            }
        }

        // Sync inputs
        pixelRange.oninput = (e) => { pixelInput.value = e.target.value; drawAll(); };
        pixelInput.oninput = (e) => { pixelRange.value = e.target.value; drawAll(); };
        brushRange.oninput = (e) => { brushInput.value = e.target.value; };
        brushInput.oninput = (e) => { brushRange.value = e.target.value; };

        function drawMask(ctx, scale = 1) {
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            const allActions = [...paths];
            if (currentPath.length > 0) {
                allActions.push({ points: currentPath, brushSize: parseInt(brushInput.value), mode: currentMode, type: 'stroke' });
            }
            allActions.forEach(action => {
                ctx.globalCompositeOperation = (action.mode === 'erase') ? 'destination-out' : 'source-over';
                if (action.type === 'fill') {
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                } else if (action.points && action.points.length >= 1) {
                    ctx.lineWidth = action.brushSize * scale;
                    ctx.strokeStyle = 'white';
                    ctx.beginPath();
                    ctx.moveTo(action.points[0].x * scale, action.points[0].y * scale);
                    action.points.forEach(p => ctx.lineTo(p.x * scale, p.y * scale));
                    ctx.stroke();
                }
            });
            ctx.globalCompositeOperation = 'source-over';
        }

        function drawAll() {
            if (!imgLoaded) return;
            const pCtx = pixelCanvas.getContext('2d');
            const mCtx = maskCanvas.getContext('2d');
            pCtx.clearRect(0, 0, pixelCanvas.width, pixelCanvas.height);
            mCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);

            drawMask(mCtx);
            pCtx.save();
            const resolution = parseInt(pixelInput.value);
            const tempCanvas = document.createElement('canvas');
            const tCtx = tempCanvas.getContext('2d');
            tempCanvas.width = resolution;
            tempCanvas.height = Math.round(resolution * (originalImg.naturalHeight / originalImg.naturalWidth));
            tCtx.imageSmoothingEnabled = false;
            tCtx.drawImage(originalImg, 0, 0, tempCanvas.width, tempCanvas.height);
            pCtx.imageSmoothingEnabled = false;
            pCtx.drawImage(tempCanvas, 0, 0, pixelCanvas.width, pixelCanvas.height);
            pCtx.globalCompositeOperation = 'destination-in';
            pCtx.drawImage(maskCanvas, 0, 0);
            pCtx.restore();
        }

        downloadBtn.onclick = () => {
            if (!imgLoaded) return;
            const naturalW = originalImg.naturalWidth;
            const naturalH = originalImg.naturalHeight;
            outputCanvas.width = naturalW;
            outputCanvas.height = naturalH;
            const scaleX = naturalW / originalImg.offsetWidth;
            const outCtx = outputCanvas.getContext('2d');

            outCtx.drawImage(originalImg, 0, 0);
            const pixelPartCanvas = document.createElement('canvas');
            pixelPartCanvas.width = naturalW;
            pixelPartCanvas.height = naturalH;
            const ppCtx = pixelPartCanvas.getContext('2d');

            const resolution = parseInt(pixelInput.value);
            const tempCanvas = document.createElement('canvas');
            const tCtx = tempCanvas.getContext('2d');
            tempCanvas.width = resolution;
            tempCanvas.height = Math.round(resolution * (naturalH / naturalW));
            tCtx.imageSmoothingEnabled = false;
            tCtx.drawImage(originalImg, 0, 0, tempCanvas.width, tempCanvas.height);
            ppCtx.imageSmoothingEnabled = false;
            ppCtx.drawImage(tempCanvas, 0, 0, naturalW, naturalH);

            const finalMaskCanvas = document.createElement('canvas');
            finalMaskCanvas.width = naturalW;
            finalMaskCanvas.height = naturalH;
            drawMask(finalMaskCanvas.getContext('2d'), scaleX);
            
            ppCtx.globalCompositeOperation = 'destination-in';
            ppCtx.drawImage(finalMaskCanvas, 0, 0);
            outCtx.drawImage(pixelPartCanvas, 0, 0);

            const link = document.createElement('a');
            link.download = 'pixel-art-export.png';
            link.href = outputCanvas.toDataURL();
            link.click();
        };

        editorWrapper.ondragover = (e) => { e.preventDefault(); editorWrapper.classList.add('drag-over'); };
        editorWrapper.ondragleave = () => { editorWrapper.classList.remove('drag-over'); };
        editorWrapper.ondrop = (e) => {
            e.preventDefault();
            editorWrapper.classList.remove('drag-over');
            if (e.dataTransfer.files.length > 0) loadFile(e.dataTransfer.files[0]);
        };

        window.onresize = () => { if (imgLoaded) { resizeCanvases(); drawAll(); } };
    </script>
</body>
</html>
